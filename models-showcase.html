<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Models Showcase</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        
        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            width: 100%;
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 0;
            z-index: 100;
        }
        
        /* Status message for selected object */
        #selectedObjectInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        
        /* Highlight for selected object */
        .selected {
            outline: 2px solid yellow;
        }
        
        /* Light Controls */
        #lightControls {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
            min-width: 220px;
        }
        
        #lightControls h3 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 80px;
        }
        
        input[type="range"] {
            vertical-align: middle;
            width: 120px;
        }
        
        input[type="color"] {
            vertical-align: middle;
            width: 30px;
            height: 30px;
        }
        
        input[type="checkbox"] {
            margin-right: 5px;
        }
        
        /* Model labels */
        .label {
            position: absolute;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border-radius: 5px;
            user-select: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">Loading models...</div>
    <div id="camelLabel" class="label">Camel</div>
    <div id="pyramidLabel" class="label">Pyramid</div>
    <div id="statueLabel" class="label">Egyptian Statue</div>
    
    <!-- Selected object information -->
    <div id="selectedObjectInfo">Bir nesne seçmek için tıklayın. Hareket için WASD tuşlarını kullanın.</div>
    
    <!-- Light Control Panel -->
    <div id="lightControls">
        <h3>Işık Kontrolü</h3>
        <div class="control-group">
            <label for="autoRotate">Otomatik Döngü:</label>
            <input type="checkbox" id="autoRotate" checked>
        </div>
        <div class="control-group">
            <label for="lightIntensity">Parlaklık:</label>
            <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="0.9">
        </div>
        <div class="control-group">
            <label for="lightColor">Renk:</label>
            <input type="color" id="lightColor" value="#ffffff">
        </div>
        <div class="control-group">
            <label for="lightX">X Pozisyonu:</label>
            <input type="range" id="lightX" min="-20" max="20" value="5">
        </div>
        <div class="control-group">
            <label for="lightY">Y Pozisyonu:</label>
            <input type="range" id="lightY" min="1" max="20" value="10">
        </div>
        <div class="control-group">
            <label for="lightZ">Z Pozisyonu:</label>
            <input type="range" id="lightZ" min="-20" max="20" value="5">
        </div>
        <div class="control-group">
            <label for="rotationSpeed">Döngü Hızı:</label>
            <input type="range" id="rotationSpeed" min="0.2" max="3" step="0.1" value="1">
        </div>
    </div>    <!-- Import Three.js directly -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/TDSLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/libs/inflate.min.js"></script> <!-- Added for better FBX support -->

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Light blue sky
        
        // Add atmospheric fog for desert depth and heat effect
        scene.fog = new THREE.FogExp2(0xE6C9A8, 0.008);
            // Camera setup - adjusted to see all models properly
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30); // Moved further back and up to see all models better
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Daha yumuşak gölgeler
        renderer.outputEncoding = THREE.sRGBEncoding; // Daha doğru renk işleme
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Sinematik ton haritalama
        renderer.toneMappingExposure = 1.2; // Biraz daha aydınlık
        document.body.appendChild(renderer.domElement);
        
        // Environment map - modellere gerçekçi yansıma vermek için
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        
        // Ortam haritası için
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        
        // Controls for camera
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Lights - improved for better model visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        // Main controllable directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);
        
        // Add a visible light source (sphere) to represent our directional light
        const lightSphereGeometry = new THREE.SphereGeometry(1, 16, 16);
        const lightSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        const lightSphere = new THREE.Mesh(lightSphereGeometry, lightSphereMaterial);
        lightSphere.position.copy(directionalLight.position);
        scene.add(lightSphere);
        
        // Light helper to visualize the directional light
        const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 2);
        scene.add(dirLightHelper);
        
        // Variables for light control
        let autoRotate = true;
        let rotationSpeed = 1.0;
        const lightRadius = 15; // Radius of rotation
        let lightAngle = 0;
        
        // Additional soft light from the front to see details better
        const frontLight = new THREE.DirectionalLight(0xffffff, 0.4);
        frontLight.position.set(0, 5, 15);
        scene.add(frontLight);
        
        // Ground plane with sandy texture - larger to accommodate spaced models
        const groundGeometry = new THREE.PlaneGeometry(70, 50, 64, 64);        // Create desert sand texture
        const textureLoader = new THREE.TextureLoader();
        const sandTexture = textureLoader.load('Free_pyramid/textures/egypt_011.jpg');
        sandTexture.wrapS = THREE.RepeatWrapping;
        sandTexture.wrapT = THREE.RepeatWrapping;
        sandTexture.repeat.set(8, 6); // Repeat to cover the large ground
        
        // Sand displacement for more realistic terrain
        const sandDisplacement = textureLoader.load('Free_pyramid/textures/egypt_011b.jpg');
        sandDisplacement.wrapS = THREE.RepeatWrapping;
        sandDisplacement.wrapT = THREE.RepeatWrapping;
        sandDisplacement.repeat.set(8, 6);
        
        const groundMaterial = new THREE.MeshStandardMaterial({
            map: sandTexture,
            displacementMap: sandDisplacement,
            displacementScale: 0.2,
            displacementBias: -0.15,
            color: 0xE6C9A8, // Sandy desert color base
            roughness: 0.9,
            metalness: 0.1
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Object references for selection and manipulation
        let camelObj = null;
        let pyramidObj = null;
        let statueObj = null;
          // Loading manager
        const manager = new THREE.LoadingManager();
        let loadingErrors = [];

manager.onLoad = function() {
    if (loadingErrors.length > 0) {
        console.error("Some models failed to load:", loadingErrors);
        document.getElementById('loading').textContent = 'Some models failed to load. Check console for details.';
        document.getElementById('loading').style.display = 'block';
    } else {
        console.log("All models loaded successfully!");
        document.getElementById('loading').style.display = 'none';
    }
    updateLabels(); // Position labels after loading attempt completes
};

manager.onProgress = function(url, itemsLoaded, itemsTotal) {
    console.log('Loading file: ' + url + ' (' + itemsLoaded + '/' + itemsTotal + ')');
};

manager.onError = function(url) {
    console.error('Error loading: ' + url);
    loadingErrors.push(url);
};
        
        manager.onLoad = function() {
            if (loadingErrors.length > 0) {
                console.error("Some models failed to load:", loadingErrors);
                document.getElementById('loading').textContent = 'Some models failed to load. Check console for details.';
                document.getElementById('loading').style.display = 'block';
            } else {
                console.log("All models loaded successfully!");
                document.getElementById('loading').style.display = 'none';
            }
            updateLabels(); // Position labels after loading attempt completes
        };
        
        manager.onProgress = function(url, itemsLoaded, itemsTotal) {
            console.log('Loading file: ' + url + ' (' + itemsLoaded + '/' + itemsTotal + ')');
        };
        
        manager.onError = function(url) {
            console.error('Error loading: ' + url);
            loadingErrors.push(url);
        };
          // Model positions - we'll place them side by side with more space between them
        const positions = {
            camel: new THREE.Vector3(-15, 0, 0),
            pyramid: new THREE.Vector3(0, 0, 0),
            statue: new THREE.Vector3(15, 0, 0)
        };
          // Load Camel model
        const tdsLoader = new THREE.TDSLoader(manager);
        tdsLoader.load(
            './camel-3ds.3DS',
            function(object) {
                console.log('Camel model loaded successfully!', object);
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        try {
                            // We'll use a proper texture for the camel - since camel has no texture,
                            // we'll borrow one that fits
                            const textureLoader = new THREE.TextureLoader(manager);
                            const camelTexture = textureLoader.load('camel2/textures/camleuvmap.png');                            // If the camel texture is unavailable, use a texture from another model
                            camelTexture.onerror = function() {
                                console.log('Using alternative texture for camel');
                                return textureLoader.load('Free_pyramid/textures/bark008.jpg');
                            };
                            
                            // Create a high-quality material for the camel
                            child.material = new THREE.MeshStandardMaterial({
                                map: camelTexture,
                                color: 0xA0522D, // Brown base color
                                roughness: 0.9,    // Rough skin
                                metalness: 0.1,
                                bumpScale: 0.02,
                                envMapIntensity: 0.5
                            });
                        } catch (e) {
                            console.warn('Could not load camel texture, using default', e);
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xA0522D, // Brown
                                roughness: 0.8,
                                metalness: 0.2
                            });
                        }
                    }
                });
                
                // Set size and position - adjusted for balanced size
                object.scale.set(0.02, 0.02, 0.02);
                object.position.copy(positions.camel);
                
                // Properly orient the camel horizontally on the ground
                // The 3DS model is originally oriented vertically, so we need to rotate it
                object.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
                
                object.name = 'camel';
                camelObj = object; // Store reference for later use
                scene.add(object);
                console.log('Camel added to scene at position:', object.position);
            },
            undefined,
            function(error) {
                console.error('Error loading camel model:', error);
                // Create fallback model when loading fails
                camelObj = createFallbackModel('camel', positions.camel);
            }
        );        // Load Pyramid model
        const fbxLoader = new THREE.FBXLoader(manager);
        fbxLoader.load(
            '"C:\\Users\\erolo\\Desktop\\computer_graphics\\21118080028\\Free_pyramid\\fbxPyra.fbx"',
            function(object) {
                console.log('Pyramid model loaded successfully!', object);
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;                        try {
                            // Ana yüzey dokusu
                            const textureLoader = new THREE.TextureLoader(manager);
                            const texture = textureLoader.load('Free_pyramid/textures/egypt_011.jpg');
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            
                            // Normal haritası için doku
                            const normalMap = textureLoader.load('Free_pyramid/textures/egypt_011b.jpg');
                            normalMap.wrapS = THREE.RepeatWrapping;
                            normalMap.wrapT = THREE.RepeatWrapping;
                            
                            // Bump haritası için doku
                            const bumpMap = textureLoader.load('Free_pyramid/textures/germany001.jpg');
                            bumpMap.wrapS = THREE.RepeatWrapping;
                            bumpMap.wrapT = THREE.RepeatWrapping;
                            
                            // Doku tekrarını kum desenine uygun hale getirelim
                            texture.repeat.set(2, 2);
                            normalMap.repeat.set(2, 2);
                            bumpMap.repeat.set(4, 4); // Daha detaylı pürüzlülük
                            
                            child.material = new THREE.MeshStandardMaterial({
                                map: texture,
                                normalMap: normalMap,
                                normalScale: new THREE.Vector2(0.5, 0.5),
                                bumpMap: bumpMap,
                                bumpScale: 0.1,
                                color: 0xE8D4AD, // Kumlu renk
                                roughness: 0.8,
                                metalness: 0.2,
                                envMapIntensity: 0.5,
                                // Gölgeleri ve pürüzleri daha belirgin yapma
                                flatShading: true
                            });
                        } catch (e) {
                            console.warn('Could not load pyramid texture', e);
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xE8D4AD, // Kumlu renk
                                roughness: 0.8,
                                metalness: 0.2
                            });
                        }
                    }
                });
                
                // Set size and position - adjusted to match other models
                object.scale.set(0.5, 0.5, 0.5);
                // Raise the pyramid slightly to align with other models
                positions.pyramid.y = 0;
                object.position.copy(positions.pyramid);
                
                object.name = 'pyramid';
                pyramidObj = object; // Store reference for later use
                scene.add(object);
                console.log('Pyramid added to scene at position:', object.position);
            },
            undefined,
            function(error) {
                console.error('Error loading pyramid model:', error);
                // Create fallback model when loading fails
                pyramidObj = createFallbackModel('pyramid', positions.pyramid);
            }
        );
        
        // Load Egyptian Statue model
        fbxLoader.load(
            './Statue_egypt1/fbxStatue.fbx',
            function(object) {
                console.log('Statue model loaded successfully!', object);
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        try {
                            const textureLoader = new THREE.TextureLoader(manager);
                            
                            // Ana doku
                            const texture = textureLoader.load('Statue_egypt1/textures/america026.jpg');
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            
                            // Normal haritası - heykelin detaylarını vurgulamak için
                            const normalMap = textureLoader.load('Statue_egypt1/textures/america026bnormal.jpg');
                            normalMap.wrapS = THREE.RepeatWrapping;
                            normalMap.wrapT = THREE.RepeatWrapping;
                            
                            // Alternatif doku da ekleyelim - renk varyasyonları için
                            const detailTexture = textureLoader.load('Statue_egypt1/textures/america026b.jpg');
                            detailTexture.wrapS = THREE.RepeatWrapping;
                            detailTexture.wrapT = THREE.RepeatWrapping;
                            
                            // Dokular için tekrar değerleri
                            texture.repeat.set(1, 1);
                            normalMap.repeat.set(1, 1);
                            
                            // Detay dokusu için UV koordinat haritalaması
                            // Heykel üzerinde detayları vurgulamak için
                            if (child.geometry && child.geometry.getAttribute('uv')) {
                                child.geometry.setAttribute('uv2', child.geometry.getAttribute('uv').clone());
                            }
                            
                            child.material = new THREE.MeshPhysicalMaterial({
                                map: texture,
                                normalMap: normalMap,
                                normalScale: new THREE.Vector2(0.8, 0.8), // Daha belirgin normal haritası
                                aoMap: detailTexture,
                                aoMapIntensity: 1.0, // Daha güçlü ambient occlusion
                                color: 0xE2C086, // Açık taş rengi
                                roughness: 0.6, // Biraz daha pürüzsüz
                                metalness: 0.05, // Az metalik görünüm
                                envMapIntensity: 0.5,
                                clearcoat: 0.1, // Hafif bir parlak kaplama
                                clearcoatRoughness: 0.8,
                                reflectivity: 0.2 // Hafif yansıma
                            });
                        } catch (e) {
                            console.warn('Could not load statue texture', e);
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xE2C086, // Açık taş rengi
                                roughness: 0.7,
                                metalness: 0.1
                            });
                        }
                    }
                });
                
                // Set size and position - scaled up to match other models
                object.scale.set(0.6, 0.6, 0.6);
                // Adjust position to ensure all models are at the same height
                positions.statue.y = 0;
                object.position.copy(positions.statue);
                
                object.name = 'statue';
                statueObj = object; // Store reference for later use
                scene.add(object);
                console.log('Statue added to scene at position:', object.position);
            },
            undefined,
            function(error) {
                console.error('Error loading statue model:', error);
                // Create fallback model when loading fails
                statueObj = createFallbackModel('statue', positions.statue);
            }
        );
        
        // Create sand particles for desert effect
        function createSandParticles() {
            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            // Create random positions for sand particles
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 60;
                positions[i * 3 + 1] = Math.random() * 8;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                sizes[i] = Math.random() * 0.1 + 0.05;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material for sand particles
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xE6C9A8,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const sandParticles = new THREE.Points(particles, particleMaterial);
            scene.add(sandParticles);
            
            return {
                geometry: particles,
                points: sandParticles,
                update: function() {
                    const positions = particles.attributes.position.array;
                    for (let i = 0; i < particleCount; i++) {
                        // Small movement for floating sand effect
                        positions[i * 3] += (Math.random() - 0.5) * 0.05;
                        positions[i * 3 + 1] += (Math.random() - 0.5) * 0.05;
                        if (positions[i * 3 + 1] < 0.1) positions[i * 3 + 1] += 0.1;
                        positions[i * 3 + 2] += (Math.random() - 0.5) * 0.05;
                    }
                    particles.attributes.position.needsUpdate = true;
                }
            };
        }
        
        // Create sand particles system
        const sandSystem = createSandParticles();
        
        // Label positioning function
        function updateLabels() {
            const labelElements = {
                camel: document.getElementById('camelLabel'),
                pyramid: document.getElementById('pyramidLabel'),
                statue: document.getElementById('statueLabel')
            };
            
            // Update label positions in animation loop
            scene.traverse(function(object) {
                if (object.name && labelElements[object.name]) {
                    const vector = new THREE.Vector3();
                    
                    // Get the position of the object in screen space
                    vector.setFromMatrixPosition(object.matrixWorld);
                    // Add some height to the label position based on model
                    if (object.name === 'camel') {
                        vector.y += 2; // Camel needs higher label
                    } else if (object.name === 'pyramid') {
                        vector.y += 3; // Pyramid needs higher label
                    } else if (object.name === 'statue') {
                        vector.y += 2.5; // Statue label position
                    }
                    vector.project(camera);
                    
                    // Convert the normalized position to CSS coordinates
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight; // Positioning based on adjusted height
                    
                    // Update the label position
                    labelElements[object.name].style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                }
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateLabels();
        });
        
        // Setup light controls
        function setupLightControls() {
            // Auto rotate toggle
            const autoRotateCheckbox = document.getElementById('autoRotate');
            autoRotateCheckbox.checked = autoRotate;
            autoRotateCheckbox.addEventListener('change', function() {
                autoRotate = this.checked;
            });
            
            // Light intensity control
            const intensitySlider = document.getElementById('lightIntensity');
            intensitySlider.value = directionalLight.intensity;
            intensitySlider.addEventListener('input', function() {
                directionalLight.intensity = parseFloat(this.value);
            });
            
            // Light color control
            const colorPicker = document.getElementById('lightColor');
            colorPicker.addEventListener('input', function() {
                const color = new THREE.Color(this.value);
                directionalLight.color.set(color);
                lightSphereMaterial.color.set(color);
            });
            
            // Light position X control
            const lightXSlider = document.getElementById('lightX');
            lightXSlider.value = directionalLight.position.x;
            lightXSlider.addEventListener('input', function() {
                if (!autoRotate) {
                    directionalLight.position.x = parseFloat(this.value);
                    lightSphere.position.copy(directionalLight.position);
                    dirLightHelper.update();
                }
            });
            
            // Light position Y control
            const lightYSlider = document.getElementById('lightY');
            lightYSlider.value = directionalLight.position.y;
            lightYSlider.addEventListener('input', function() {
                directionalLight.position.y = parseFloat(this.value);
                lightSphere.position.copy(directionalLight.position);
                dirLightHelper.update();
            });
            
            // Light position Z control
            const lightZSlider = document.getElementById('lightZ');
            lightZSlider.value = directionalLight.position.z;
            lightZSlider.addEventListener('input', function() {
                if (!autoRotate) {
                    directionalLight.position.z = parseFloat(this.value);
                    lightSphere.position.copy(directionalLight.position);
                    dirLightHelper.update();
                }
            });
            
            // Rotation speed control
            const speedSlider = document.getElementById('rotationSpeed');
            speedSlider.value = rotationSpeed;
            speedSlider.addEventListener('input', function() {
                rotationSpeed = parseFloat(this.value);
            });
        }
        
        // Call setup once DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            setupLightControls();
        });
        
        // Update light position in a circular path
        function updateLightPosition() {
            if (autoRotate) {
                lightAngle += 0.01 * rotationSpeed;
                
                // Update directional light position in a circular path
                directionalLight.position.x = Math.sin(lightAngle) * lightRadius;
                directionalLight.position.z = Math.cos(lightAngle) * lightRadius;
                
                // Update sliders to reflect current position when in auto mode
                document.getElementById('lightX').value = directionalLight.position.x;
                document.getElementById('lightZ').value = directionalLight.position.z;
                
                // Update the visible light sphere to match the light position
                lightSphere.position.copy(directionalLight.position);
                
                // Update the light helper
                dirLightHelper.update();
            }
        }
        
        // ---- OBJECT SELECTION AND MOVEMENT FUNCTIONALITY ----
        
        // Object selection and movement variables
        let selectedObject = null;
        const moveSpeed = 0.2;
        const keyState = {
            'w': false, 
            'a': false, 
            's': false, 
            'd': false
        };
        const selectedObjectInfo = document.getElementById('selectedObjectInfo');
        
        // Raycaster for object selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Handle mouse click for object selection
        document.addEventListener('click', function(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // If we've clicked on an object
            if (intersects.length > 0) {
                // Find the actual parent object (camel, pyramid or statue)
                let clickedObject = intersects[0].object;
                let parentObject = null;
                
                // Traverse up to find the named parent
                while (clickedObject && !parentObject) {
                    if (clickedObject.name === 'camel' || 
                        clickedObject.name === 'pyramid' || 
                        clickedObject.name === 'statue') {
                        parentObject = clickedObject;
                    } else if (clickedObject.parent) {
                        clickedObject = clickedObject.parent;
                    } else {
                        break;
                    }
                }
                
                // If we found a valid parent (one of our models)
                if (parentObject) {
                    // Deselect previous object if any
                    if (selectedObject) {
                        // Remove any highlight or indication of selection
                    }
                    
                    // Select new object
                    selectedObject = parentObject;
                    selectedObjectInfo.textContent = `"${selectedObject.name}" seçildi. WASD tuşları ile hareket ettirebilirsiniz.`;
                    
                    // Disable orbit controls when object is selected for movement
                    controls.enabled = false;
                    
                    // Store original position for reference
                    selectedObject.userData.originalPosition = selectedObject.position.clone();
                }
            } else {
                // If clicked on empty space, deselect
                if (selectedObject) {
                    selectedObject = null;
                    selectedObjectInfo.textContent = "Bir nesne seçmek için tıklayın. Hareket için WASD tuşlarını kullanın.";
                    // Re-enable orbit controls
                    controls.enabled = true;
                }
            }
        });
        
        // Handle keyboard input
        document.addEventListener('keydown', function(event) {
            if (selectedObject) {
                const key = event.key.toLowerCase();
                if (key in keyState) {
                    keyState[key] = true;
                    event.preventDefault(); // Prevent scrolling with keys
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            const key = event.key.toLowerCase();
            if (key in keyState) {
                keyState[key] = false;
            }
        });
        
        // Move selected object based on key states
        function moveSelectedObject() {
            if (selectedObject) {
                // Get the camera's view direction
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                
                // Create forward and right vectors relative to camera
                const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
                
                // Apply movement based on key states
                if (keyState.w) { // Forward
                    selectedObject.position.add(forward.clone().multiplyScalar(moveSpeed));
                }
                if (keyState.s) { // Backward
                    selectedObject.position.add(forward.clone().multiplyScalar(-moveSpeed));
                }
                if (keyState.a) { // Left
                    selectedObject.position.add(right.clone().multiplyScalar(-moveSpeed));
                }
                if (keyState.d) { // Right
                    selectedObject.position.add(right.clone().multiplyScalar(moveSpeed));
                }
                
                // Update the object's position in our positions dictionary for label updates
                if (positions[selectedObject.name]) {
                    positions[selectedObject.name].copy(selectedObject.position);
                }
            }
        }
        
        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Only animate models if they're not selected
            if (camelObj && (!selectedObject || selectedObject.name !== 'camel')) {
                camelObj.rotation.z = Math.sin(time * 0.5) * 0.02; // Subtle swaying
                camelObj.position.y = 2.3 + Math.sin(time * 0.8) * 0.05; // Subtle up/down
            }
            
            if (statueObj && (!selectedObject || selectedObject.name !== 'statue')) {
                // Very subtle rotation for mystical effect
                statueObj.rotation.y = Math.sin(time * 0.2) * 0.01;
            }
            
            // Move the selected object based on WASD keys
            moveSelectedObject();
            
            // Update sand particles
            sandSystem.update();
            
            // Update other components
            controls.update();
            updateLabels();
            updateLightPosition();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Initialize controls
        setupLightControls();
        
        // Fallback model creation function
function createFallbackModel(name, position) {
    console.log(`Creating fallback for ${name}`);
    let geometry, material, mesh;
    
    if (name === 'camel') {
        // Create a more camel-like shape using multiple geometries
        const body = new THREE.BoxGeometry(3, 1.2, 1.5);
        const bodyMesh = new THREE.Mesh(body, new THREE.MeshStandardMaterial({ color: 0xA0522D }));
        
        const neck = new THREE.BoxGeometry(0.7, 1.5, 0.7);
        const neckMesh = new THREE.Mesh(neck, new THREE.MeshStandardMaterial({ color: 0xA0522D }));
        neckMesh.position.set(1.5, 0.8, 0);
        neckMesh.rotation.z = Math.PI / 6; // Angle the neck
        
        const head = new THREE.BoxGeometry(1.2, 0.7, 0.7);
        const headMesh = new THREE.Mesh(head, new THREE.MeshStandardMaterial({ color: 0xA0522D }));
        headMesh.position.set(2.2, 1.5, 0);
        
        // Create legs
        const legs = [];
        const legPositions = [
            [-0.8, -0.9, 0.5], // front left
            [-0.8, -0.9, -0.5], // front right
            [0.8, -0.9, 0.5], // back left
            [0.8, -0.9, -0.5] // back right
        ];
        
        for (let pos of legPositions) {
            const leg = new THREE.BoxGeometry(0.4, 1.5, 0.4);
            const legMesh = new THREE.Mesh(leg, new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            legMesh.position.set(...pos);
            legs.push(legMesh);
        }
        
        // Create a group to hold all parts
        mesh = new THREE.Group();
        mesh.add(bodyMesh);
        mesh.add(neckMesh);
        mesh.add(headMesh);
        legs.forEach(leg => mesh.add(leg));
        
    } else if (name === 'pyramid') {
        // Create a more realistic pyramid with a square base
        geometry = new THREE.ConeGeometry(3, 4, 4);
        material = new THREE.MeshStandardMaterial({ 
            color: 0xE8D4AD,
            roughness: 0.8,
            metalness: 0.1
        });
        mesh = new THREE.Mesh(geometry, material);
        // Rotate to align base properly
        mesh.rotation.y = Math.PI / 4;
        
    } else if (name === 'statue') {
        // Create a more statue-like shape
        const base = new THREE.CylinderGeometry(1, 1, 0.5, 16);
        const baseMesh = new THREE.Mesh(base, new THREE.MeshStandardMaterial({ color: 0xE2C086 }));
        baseMesh.position.y = -1.5;
        
        const body = new THREE.CylinderGeometry(0.7, 0.9, 2.5, 16);
        const bodyMesh = new THREE.Mesh(body, new THREE.MeshStandardMaterial({ color: 0xE2C086 }));
        
        const head = new THREE.SphereGeometry(0.6, 16, 16);
        const headMesh = new THREE.Mesh(head, new THREE.MeshStandardMaterial({ color: 0xE2C086 }));
        headMesh.position.y = 1.5;
        
        // Create a group to hold all parts
        mesh = new THREE.Group();
        mesh.add(baseMesh);
        mesh.add(bodyMesh);
        mesh.add(headMesh);
    }
    
    mesh.position.copy(position);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.name = name;
    scene.add(mesh);
    
    return mesh;
}
    </script>
</body>
</html>
